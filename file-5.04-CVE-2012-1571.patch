diff --git a/src/cdf.c b/src/cdf.c
index 66cf2e3..0a66c64 100644
--- a/src/cdf.c
+++ b/src/cdf.c
@@ -75,6 +75,7 @@ static union {
 #define CDF_TOLE4(x)	((uint32_t)(NEED_SWAP ? cdf_tole4(x) : (uint32_t)(x)))
 #define CDF_TOLE2(x)	((uint16_t)(NEED_SWAP ? cdf_tole2(x) : (uint16_t)(x)))
 
+
 /*
  * swap a short
  */
@@ -310,18 +311,27 @@ ssize_t
 cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,
     const cdf_header_t *h, cdf_secid_t id)
 {
-	assert((size_t)CDF_SEC_SIZE(h) == len);
-	return cdf_read(info, (off_t)CDF_SEC_POS(h, id),
-	    ((char *)buf) + offs, len);
+	size_t ss = CDF_SEC_SIZE(h);
+	size_t pos = CDF_SEC_POS(h, id);
+	assert(ss == len);
+	return cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);
 }
 
 ssize_t
 cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,
     size_t len, const cdf_header_t *h, cdf_secid_t id)
 {
-	assert((size_t)CDF_SHORT_SEC_SIZE(h) == len);
+	size_t ss = CDF_SHORT_SEC_SIZE(h);
+	size_t pos = CDF_SHORT_SEC_POS(h, id);
+	assert(ss == len);
+	if (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {
+		DPRINTF(("Out of bounds read %lu > %"
+		"l" "u\n",
+		pos + len, CDF_SEC_SIZE(h) * sst->sst_len));
+		return -1;
+	}
 	(void)memcpy(((char *)buf) + offs,
-	    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);
+		((const char *)sst->sst_tab) + pos, len);
 	return len;
 }
 
@@ -341,7 +351,7 @@ cdf_read_sat(const cdf_info_t *info, cdf_header_t *h, cdf_sat_t *sat)
 			break;
 
 #define CDF_SEC_LIMIT (UINT32_MAX / (4 * ss))
-	if (h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec ||
+	if ((nsatpersec > 0 && h->h_num_sectors_in_master_sat > CDF_SEC_LIMIT / nsatpersec) ||
 	    i > CDF_SEC_LIMIT) {
 		DPRINTF(("Number of sectors in master SAT too big %u %zu\n",
 		    h->h_num_sectors_in_master_sat, i));
@@ -754,9 +764,14 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
+		size_t tail = (i << 1) + 1;
+		if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),
+		    __LINE__) == -1)
+			goto out;
+		size_t ofs = CDF_TOLE4(p[tail]);
 		q = (const uint32_t *)(const void *)
-		    ((const char *)(const void *)p +
-		    CDF_TOLE4(p[(i << 1) + 1])) - 2;
+		    ((const char *)(const void *)p + ofs
+		    - 2 * sizeof(uint32_t));
 		if (q > e) {
 			DPRINTF(("Ran of the end %p > %p\n", q, e));
 			goto out;
@@ -813,6 +828,20 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t
 			(void)memcpy(&u64, &q[o], sizeof(u64));
 			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
 			break;
+		case CDF_FLOAT:
+			if (inp[i].pi_type & CDF_VECTOR)
+				goto unknown;
+			(void)memcpy(&u32, &q[o], sizeof(u32));
+			u32 = CDF_TOLE4(u32);
+			memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));
+			break;
+		case CDF_DOUBLE:
+			if (inp[i].pi_type & CDF_VECTOR)
+				goto unknown;
+			(void)memcpy(&u64, &q[o], sizeof(u64));
+			u64 = CDF_TOLE8((uint64_t)u64);
+			memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));
+			break;
 		case CDF_LENGTH32_STRING:
 		case CDF_LENGTH32_WSTRING:
 			if (nelements > 1) {
@@ -839,6 +868,8 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t
 				    inp[i].pi_str.s_buf));
 				l = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));
 				o += l >> 2;
+				if (q + o >= e)
+					goto out;
 			}
 			i--;
 			break;
@@ -856,7 +887,7 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t
 		unknown:
 			DPRINTF(("Don't know how to deal with %x\n",
 			    inp[i].pi_type));
-			goto out;
+			break;
 		}
 	}
 	return 0;
@@ -889,8 +920,9 @@ cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h, cdf_summ
 	maxcount = 0;
 	*info = NULL;
 	if (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,
-	    count, &maxcount) == -1)
+	    count, &maxcount) == -1) {
 		return -1;
+	}
 	return 0;
 }
 
@@ -1136,6 +1168,14 @@ cdf_dump_property_info(const cdf_property_info_t *info, size_t count)
 			(void)fprintf(stderr, "unsigned 32 [%u]\n",
 			    info[i].pi_u32);
 			break;
+		case CDF_FLOAT:
+			(void)fprintf(stderr, "float [%g]\n",
+			    info[i].pi_f);
+			break;
+		case CDF_DOUBLE:
+			(void)fprintf(stderr, "double [%g]\n",
+			    info[i].pi_d);
+			break;
 		case CDF_LENGTH32_STRING:
 			(void)fprintf(stderr, "string %u [%.*s]\n",
 			    info[i].pi_str.s_len,
diff --git a/src/cdf.h b/src/cdf.h
index bb45db5..c781200 100644
--- a/src/cdf.h
+++ b/src/cdf.h
@@ -61,9 +61,9 @@ typedef struct {
 	cdf_secid_t	h_master_sat[436/4];
 } cdf_header_t;
 
-#define CDF_SEC_SIZE(h)	(1 << (h)->h_sec_size_p2)
+#define CDF_SEC_SIZE(h)	((size_t)(1 << (h)->h_sec_size_p2))
 #define CDF_SEC_POS(h, secid) (CDF_SEC_SIZE(h) + (secid) * CDF_SEC_SIZE(h))
-#define CDF_SHORT_SEC_SIZE(h)	(1 << (h)->h_short_sec_size_p2)
+#define CDF_SHORT_SEC_SIZE(h)	((size_t)(1 << (h)->h_short_sec_size_p2))
 #define CDF_SHORT_SEC_POS(h, secid) ((secid) * CDF_SHORT_SEC_SIZE(h))
 
 typedef int32_t	cdf_dirid_t;
@@ -155,6 +155,8 @@ typedef struct {
 		uint64_t	_pi_u64;
 		int64_t		_pi_s64;
 		cdf_timestamp_t	_pi_tp;
+		float		_pi_f;
+		double		_pi_d;
 		struct {
 			uint32_t s_len;
 			const char *s_buf;
@@ -166,6 +168,8 @@ typedef struct {
 #define pi_s32	pi_val._pi_s32
 #define pi_u16	pi_val._pi_u16
 #define pi_s16	pi_val._pi_s16
+#define pi_f	pi_val._pi_f
+#define pi_d	pi_val._pi_d
 #define pi_tp	pi_val._pi_tp
 #define pi_str	pi_val._pi_str
 } cdf_property_info_t;
diff --git a/src/readcdf.c b/src/readcdf.c
index e05a50c..26fe7cb 100644
--- a/src/readcdf.c
+++ b/src/readcdf.c
@@ -72,6 +72,16 @@ cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,
 			    info[i].pi_u32) == -1)
 				return -1;
 			break;
+		case CDF_FLOAT:
+				if (NOTMIME(ms) && file_printf(ms, ", %s: %g", buf,
+					info[i].pi_f) == -1)
+						return -1;
+				break;
+		case CDF_DOUBLE:
+				if (NOTMIME(ms) && file_printf(ms, ", %s: %g", buf,
+					info[i].pi_d) == -1)
+						return -1;
+				break;
 		case CDF_LENGTH32_STRING:
 		case CDF_LENGTH32_WSTRING:
 			len = info[i].pi_str.s_len;
diff --git a/src/softmagic.c b/src/softmagic.c
index 107876c..9a24bc2 100644
--- a/src/softmagic.c
+++ b/src/softmagic.c
@@ -94,7 +94,7 @@ private void cvt_64(union VALUETYPE *, const struct magic *);
  */
 /*ARGSUSED1*/		/* nbytes passed for regularity, maybe need later */
 protected int
-file_softmagic(struct magic_set *ms, const unsigned char *buf, size_t level, size_t nbytes, int mode)
+file_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes, size_t level, int mode)
 {
 	struct mlist *ml;
 	int rv;
@@ -1503,7 +1503,7 @@ mget(struct magic_set *ms, const unsigned char *s,
 			return -1;
 		if (nbytes < offset)
 			return 0;
-		return file_softmagic(ms, s + offset, recursion_level, nbytes - offset,
+		return file_softmagic(ms, s + offset, nbytes - offset, recursion_level,
 		    BINTEST);
 
 	case FILE_DEFAULT:	/* nothing to check */
